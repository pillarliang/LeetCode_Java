



5. 并发与并行
	1. 你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。
	2. 你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。
	3. 并发的关键是你有处理多个任务的能力，不一定要同时。并行的关键是你有同时处理多个任务的能力。所以我认为它们最关键的点就是：是否是『同时』。

6. 上下文切换
	当前任务在执行完CPU时间片，切换到另一个任务之前先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。
	任务从保存到再加载的过程就是一次上下文切换

7. 线程死锁
	1. 定义：两个线程同时想申请对方的资源，所以两个线程都会互相等待而进入死锁状态
	2. 产生死锁的四个必备条件：
		1. 互斥条件：		该资源任意一个时刻只能由一个线程占用
		2. 请求与保持条件：   一个进程因请求资源而阻塞时候，对已获得的资源保持不放
		3. 不剥夺条件：       线程已获得的资源在未使用完之前不能被其他线程强行剥夺
		4. 循环等待条件：		若干进程形成一种头尾相接的循环等待资源关系
	3. 破坏这四个之一，就会避免死锁

8. Sleep()和 wait()的区别
	1. sleep没有释放锁，wait有释放锁
	2. wait用于线程间的通信，sleep通常用于暂停执行
	3. wait方法调用后，线程不会自动苏醒。但是sleep会

9. 为什么调用start()执行run方法，而不是直接执行run方法
	1. 调用start方法可以启动线程并使线程进入就绪状态，而run方法只是thread的一个普通方法调用，还是在主线程里执行

10. synchronized
	1. 作用： synchronized 关键词可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行
	  	
		  ![](https://i.imgur.com/YGT8NoB.png)
	2. synchronized三种使用方法：
		1. 修饰实例方法：对当前对象实例加锁
		2. 修饰静态方法：对当前类加锁，会作用于类的所有对象实例
		3. 修饰代码块
		3. 单例模式： 
			1. 这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。

11. Volatile:
	1. 告诉JVM该变量不稳定，每次使用它到主存中去读取
	2. 与synchronized区别：
		1. volatile更轻量级
		2. volatile只能用于变量，但是synchronized可以修饰方法和代码块
		3. 多线程访问volatile不会堵塞
		4. volatile能保证数据的可见性，但不能保证原子性；synchronized两者都能保证
		5. volatile主要解决变量在多线程之间的可见性，synchronized解决多个线程访问资源的同步性

12. ThreadLocal:
	1. 定义：让每一个线程有有自己的专属本地变量，创建一个ThreadLocal变量，每一个访问该变量的线程都会有这个变量的本地副本

13. 线程池
	1. 定义： 其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。
	2. 使用线程池中线程对象的步骤：
		1. 创建线程池对象。
		2. 创建Runnable接口子类对象。(task)
		3. 提交Runnable接口子类对象。(take task)
		4. 关闭线程池(一般不做)。
	3. 优点：
		1. 降低资源消耗
		2. 提高响应速度
		3. 提高线程的可管理性

	4. Runnable和Callable接口的区别：
		1. runnable不需要返回结果或抛出检查异常，而callable可以
	5. execute()和submit()区别：
		1. execute方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功
		2. submit方法用于提交需要返回值的任务，通过返回一个Future类型对象可以判断是否执行成功
	6. 创建线程原理
		![](https://i.imgur.com/qP03vr2.png)



2. 线程和进程
	1. 进程是程序的一次执行过程，各进程是独立的
	2. 同类多个线程共享进程的堆和方法区资源
	3. 但是每个线程都有自己的程序计数器，虚拟机栈，本地方法栈
		![](https://i.imgur.com/0TazcwD.png)

	1. 线程私有的：
		程序计数器
		虚拟机栈
		本地方法栈
	2. 线程共享的：
		堆
		方法区
		直接内存(非运行时数据区的一部分)

3. 程序计数器
	1. 多线程情况下，程序计数器用来记录当前线程执行的位置，从而当线程被切换回来的时候能够知道上次运行到哪里了
	2. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行，选择，循环，异常处理
	

4. 堆和方法区	
	1. 堆：进程中最大的一块内存，用来存放新创建的对象，所有对象都在这里被分配内存
	2. 方法区：存放已被加载的类信息，常量，静态方法，即时编译器编译后的代码等数据
		